# MoFA Studio 架构指南

本文档描述了 MoFA Studio 的模块化架构。这是一个使用 Makepad UI 框架构建的桌面应用程序，其中应用程序是自包含的组件，可以插入轻量级的外壳程序中。

## 项目概述

**MoFA Studio** 是一个基于 AI 的桌面应用程序，用于语音聊天和模型管理，使用 Rust 和 Makepad 构建。

- **版本**: 0.1.0
- **Rust 版本**: 2021
- **许可证**: Apache-2.0
- **代码仓库**: https://github.com/YOUR_ORG/mofa-studio
- **UI 框架**: Makepad（GPU 加速，即时模式）

## 目录结构

```
mofa-studio/
├── Cargo.toml              # 工作空间配置
├── ARCHITECTURE.md         # 架构指南（英文）
├── 架构指南.md              # 本文件（中文）
├── mofa-widgets/           # 共享可复用组件（库）
│   ├── src/
│   │   ├── lib.rs          # 模块导出和 live_design 注册
│   │   ├── theme.rs        # 字体和颜色
│   │   ├── participant_panel.rs  # 发言者状态卡片
│   │   ├── log_panel.rs    # 可滚动日志显示
│   │   ├── waveform_view.rs     # 音频可视化
│   │   ├── led_gauge.rs    # LED 指示条
│   │   └── audio_player.rs # 音频播放
│   └── resources/
│       └── fonts/          # Manrope 字体文件
├── mofa-studio-shell/      # 主外壳应用程序（可执行文件）
│   ├── src/
│   │   ├── main.rs         # 入口点
│   │   ├── lib.rs          # SharedState 定义
│   │   ├── app.rs          # 主 App 组件（约 1,120 行）
│   │   └── widgets/
│   │       ├── mod.rs
│   │       ├── sidebar.rs  # 导航侧边栏（约 550 行）
│   │       ├── log_panel.rs
│   │       └── participant_panel.rs
│   └── resources/
│       ├── fonts/          # Manrope 字体文件
│       ├── icons/          # SVG 图标
│       └── mofa-logo.png   # 应用程序 Logo
└── apps/
    ├── mofa-fm/            # MoFA FM 应用（库）
    │   ├── src/
    │   │   ├── lib.rs
    │   │   ├── screen.rs   # 主屏幕（约 1,360 行）
    │   │   ├── mofa_hero.rs # 状态栏（约 660 行）
    │   │   └── audio.rs    # 音频设备管理
    │   └── resources/
    └── mofa-settings/      # 设置应用（库）
        ├── src/
        │   ├── lib.rs
        │   ├── screen.rs   # 设置屏幕（约 415 行）
        │   ├── providers_panel.rs  # 提供商列表（约 320 行）
        │   ├── provider_view.rs    # 提供商配置（约 640 行）
        │   ├── add_provider_modal.rs  # 添加提供商对话框
        │   └── data/
        │       ├── mod.rs
        │       ├── providers.rs    # 提供商数据类型
        │       └── preferences.rs  # 用户偏好设置
        └── resources/
            └── icons/      # 提供商图标
```

## Crate 依赖关系

```
mofa-studio-shell（可执行文件）
├── makepad-widgets
├── mofa-widgets
├── mofa-fm（可选，默认启用）
├── mofa-settings（可选，默认启用）
├── cpal（音频）
├── tokio（异步运行时）
├── parking_lot（同步）
├── serde, serde_json（序列化）
├── dirs（用户目录）
├── sysinfo（系统指标）
└── log, ctrlc

mofa-fm（库）
├── makepad-widgets
├── mofa-widgets
├── cpal
├── parking_lot
├── sysinfo
└── log

mofa-settings（库）
├── makepad-widgets
├── mofa-widgets
├── serde, serde_json
├── dirs
├── parking_lot
└── log

mofa-widgets（库）
├── makepad-widgets
├── cpal
├── parking_lot
├── crossbeam-channel
└── log
```

## 架构原则

### 核心原则：黑盒应用

应用程序是自包含的组件。外壳程序对其内部结构一无所知。

**外壳程序职责：**
- 窗口框架（标题栏、按钮）
- 导航（侧边栏、标签栏）
- 应用切换（可见性切换）
- 组件注册

**外壳程序不应该：**
- 了解应用内部组件
- 处理应用特定的事件
- 存储应用特定的状态

**应用程序职责：**
- 所有内部 UI 布局
- 所有内部事件
- 所有内部状态
- 自己的资源文件

### 最小耦合（仅 4 个点）

#### 1. 导入语句
```rust
// mofa-studio-shell/src/app.rs
use mofa_fm::screen::MoFaFMScreen;
use mofa_settings::screen::SettingsScreen;
```

#### 2. 组件注册（顺序很重要！）
```rust
impl LiveRegister for App {
    fn live_register(cx: &mut Cx) {
        makepad_widgets::live_design(cx);
        mofa_widgets::live_design(cx);           // 首先是共享组件
        mofa_studio_shell::widgets::sidebar::live_design(cx);
        mofa_studio_shell::widgets::log_panel::live_design(cx);
        mofa_studio_shell::widgets::participant_panel::live_design(cx);
        mofa_fm::live_design(cx);                // 然后是应用
        mofa_settings::live_design(cx);
    }
}
```

#### 3. 组件实例化
```rust
live_design! {
    content = <View> {
        flow: Overlay
        fm_page = <MoFaFMScreen> {
            width: Fill, height: Fill
            visible: true
        }
        settings_page = <SettingsScreen> {
            width: Fill, height: Fill
            visible: false
        }
    }
}
```

#### 4. 可见性切换
```rust
// 通过 apply_over 导航
self.ui.view(ids!(content.fm_page)).apply_over(cx, live!{ visible: true });
self.ui.view(ids!(content.settings_page)).apply_over(cx, live!{ visible: false });
self.ui.redraw(cx);
```

## 组件层次结构

```
Window（1400x900）
├── Dashboard（基础层）
│   ├── Header
│   │   ├── 汉堡按钮（21x21）
│   │   ├── Logo（40x40）
│   │   ├── 标题 "MoFA Studio"
│   │   └── 用户头像容器
│   └── Content Area
│       └── Main Content（Overlay）
│           ├── fm_page（MoFaFMScreen）
│           │   ├── MofaHero（状态栏）
│           │   │   ├── 操作区（启动/停止）
│           │   │   ├── 连接区
│           │   │   ├── 缓冲区
│           │   │   ├── CPU 区
│           │   │   └── 内存区
│           │   ├── 参与者容器
│           │   │   ├── 学生 1 面板
│           │   │   ├── 学生 2 面板
│           │   │   └── 导师面板
│           │   ├── 聊天容器
│           │   └── 音频控制面板
│           ├── app_page（占位符）
│           └── settings_page（SettingsScreen）
│               ├── ProvidersPanel（左侧）
│               ├── VerticalDivider
│               ├── ProviderView（右侧）
│               └── AddProviderModal（覆盖层）
├── Tab Overlay（模态层）
│   ├── Tab Bar
│   └── Tab Content
├── Sidebar Menu Overlay（滑动动画）
│   └── Sidebar
│       ├── MoFA FM 标签
│       ├── 应用列表（1-20）
│       │   ├── 应用 1-4（始终可见）
│       │   ├── 固定应用（用于 Show More 选择）
│       │   ├── Show More 按钮
│       │   └── 更多应用区（5-20，可折叠）
│       └── 设置标签
├── User Menu Overlay
└── Sidebar Trigger Overlay（28x28）
```

## 状态管理

### 外壳程序状态（app.rs）
```rust
pub struct App {
    #[live] ui: WidgetRef,

    // 菜单状态
    #[rust] user_menu_open: bool,
    #[rust] sidebar_menu_open: bool,

    // 标签系统
    #[rust] open_tabs: Vec<String>,      // "profile", "settings"
    #[rust] active_tab: Option<String>,

    // 响应式布局
    #[rust] last_window_size: DVec2,

    // 侧边栏动画
    #[rust] sidebar_animating: bool,
    #[rust] sidebar_animation_start: f64,
    #[rust] sidebar_slide_in: bool,
}
```

### 侧边栏状态（sidebar.rs）
```rust
pub struct Sidebar {
    #[deref] view: View,
    #[rust] more_apps_visible: bool,
    #[rust] selection: Option<SidebarSelection>,
    #[rust] pinned_app_name: Option<String>,
}

pub enum SidebarSelection {
    MofaFM,
    App(usize),  // 1-20
    Settings,
}
```

### 设置状态（screen.rs）
```rust
pub struct SettingsScreen {
    #[deref] view: View,
    #[rust] preferences: Option<Preferences>,
    #[rust] selected_provider_id: Option<ProviderId>,
}
```

### 共享状态（lib.rs）
```rust
pub struct SharedState {
    pub buffer_fill: f64,
    pub is_connected: bool,
    pub cpu_usage: f32,
    pub memory_usage: f32,
}

pub type SharedStateRef = Arc<Mutex<SharedState>>;
```

## 动画系统

### 侧边栏滑动动画
```rust
// 动画参数
const ANIMATION_DURATION: f64 = 0.2;  // 200ms
const SIDEBAR_WIDTH: f64 = 180.0;

// 缓出三次方缓动
let eased = 1.0 - (1.0 - progress).powi(3);

// 位置计算
let x = if slide_in {
    -SIDEBAR_WIDTH * (1.0 - eased)  // -180 -> 0
} else {
    -SIDEBAR_WIDTH * eased           // 0 -> -180
};

// 通过 abs_pos 应用
self.ui.view(ids!(sidebar_menu_overlay)).apply_over(cx, live!{
    abs_pos: (dvec2(x, 52.0))
});
```

## 主题系统

### 字体（多语言支持）
```rust
// 所有字体支持：拉丁文、中文（霞鹜文楷）、Emoji（NotoColorEmoji）
FONT_REGULAR    // 普通文本
FONT_MEDIUM     // 稍粗
FONT_SEMIBOLD   // 章节标题
FONT_BOLD       // 标题
```

### 颜色调色板
```rust
// 背景色
DARK_BG = #f5f7fa        // 页面背景（浅灰色）
PANEL_BG = #ffffff       // 卡片/面板背景（白色）

// 强调色
ACCENT_BLUE = #3b82f6    // 主要操作
ACCENT_GREEN = #10b981   // 成功/激活

// 文本颜色
TEXT_PRIMARY = #1f2937   // 主要文本（深灰色）
TEXT_SECONDARY = #6b7280 // 次要文本（中灰色）

// UI 颜色
边框: #e2e8f0, #e5e7eb
悬停: #f1f5f9
选中: #dbeafe（浅蓝色）
状态: 绿色 #22c55e, 黄色 #f59e0b, 红色 #ef4444
```

## 数据模型

### 提供商配置
```rust
pub enum ProviderType {
    OpenAi,
    DeepSeek,
    AlibabaCloud,
    Custom,
}

pub enum ProviderConnectionStatus {
    Disconnected,
    Connecting,
    Connected,
    Error(String),
}

pub struct Provider {
    pub id: ProviderId,
    pub name: String,
    pub url: String,
    pub api_key: Option<String>,
    pub provider_type: ProviderType,
    pub enabled: bool,
    pub models: Vec<String>,
    pub is_custom: bool,
    pub connection_status: ProviderConnectionStatus,
}
```

### 音频设备信息
```rust
pub struct AudioDeviceInfo {
    pub name: String,
    pub is_default: bool,
}
```

## 创建新应用

### 步骤 1：创建 Crate 结构
```
apps/my-app/
├── Cargo.toml
├── src/
│   ├── lib.rs
│   └── screen.rs
└── resources/
    └── icons/
```

### 步骤 2：定义 Cargo.toml
```toml
[package]
name = "my-app"
version.workspace = true
edition.workspace = true

[lib]
path = "src/lib.rs"

[dependencies]
makepad-widgets.workspace = true
mofa-widgets = { path = "../../mofa-widgets" }
```

### 步骤 3：创建 lib.rs
```rust
mod screen;
pub use screen::*;

use makepad_widgets::*;

pub fn live_design(cx: &mut Cx) {
    screen::live_design(cx);
}
```

### 步骤 4：创建 screen.rs
```rust
use makepad_widgets::*;

live_design! {
    use link::theme::*;
    use link::shaders::*;
    use link::widgets::*;
    use mofa_widgets::theme::*;

    pub MyAppScreen = {{MyAppScreen}} {
        width: Fill, height: Fill
        flow: Down
        show_bg: true
        draw_bg: { color: (DARK_BG) }

        // 你的 UI 在这里
    }
}

#[derive(Live, LiveHook, Widget)]
pub struct MyAppScreen {
    #[deref]
    view: View,

    #[rust]
    my_state: bool,
}

impl Widget for MyAppScreen {
    fn handle_event(&mut self, cx: &mut Cx, event: &Event, scope: &mut Scope) {
        self.view.handle_event(cx, event, scope);
        // 处理事件
    }

    fn draw_walk(&mut self, cx: &mut Cx2d, scope: &mut Scope, walk: Walk) -> DrawStep {
        self.view.draw_walk(cx, scope, walk)
    }
}
```

### 步骤 5：在外壳程序中注册

添加到 `mofa-studio-shell/Cargo.toml`：
```toml
[features]
default = ["mofa-fm", "mofa-settings", "my-app"]
my-app = ["dep:my-app"]

[dependencies]
my-app = { path = "../apps/my-app", optional = true }
```

添加到 `mofa-studio-shell/src/app.rs`：
```rust
use my_app::screen::MyAppScreen;

impl LiveRegister for App {
    fn live_register(cx: &mut Cx) {
        // ... 现有注册 ...
        my_app::live_design(cx);
    }
}
```

添加到 live_design：
```rust
content = <View> {
    flow: Overlay
    fm_page = <MoFaFMScreen> { ... }
    my_app_page = <MyAppScreen> {
        width: Fill, height: Fill
        visible: false
    }
    settings_page = <SettingsScreen> { ... }
}
```

### 步骤 6：添加导航

在 `widgets/sidebar.rs` 中添加侧边栏按钮：
```rust
my_app_tab = <SidebarMenuButton> {
    text: "我的应用"
    draw_icon: {
        svg_file: dep("crate://self/resources/icons/my-app.svg")
    }
}
```

在 app.rs 中添加点击处理器：
```rust
if self.ui.button(ids!(sidebar_menu_overlay.sidebar_content.my_app_tab)).clicked(&actions) {
    self.sidebar_menu_open = false;
    self.start_sidebar_slide_out(cx);
    // 切换可见性...
}
```

## 事件处理模式

### 悬停事件（重要！）
悬停事件（`FingerHoverIn`/`FingerHoverOut`）必须在 `Event::Actions` 的提前返回**之前**处理：

```rust
fn handle_event(&mut self, cx: &mut Cx, event: &Event, scope: &mut Scope) {
    self.view.handle_event(cx, event, scope);

    // 在提取 actions 之前处理悬停
    for item in &items {
        match event.hits(cx, item.area()) {
            Hit::FingerHoverIn(_) => { /* 悬停效果 */ }
            Hit::FingerHoverOut(_) => { /* 重置 */ }
            _ => {}
        }
    }

    // 然后提取 actions
    let actions = match event {
        Event::Actions(actions) => actions.as_slice(),
        _ => return,  // 在悬停处理之后提前返回
    };

    // 处理点击
}
```

### 按钮点击
```rust
if self.view.button(ids!(my_button)).clicked(actions) {
    // 处理点击
}
```

### View 手指事件
```rust
if self.view.view(ids!(my_view)).finger_up(actions).is_some() {
    // 处理 View 上的手指抬起
}
```

## 最佳实践

1. **保持应用自包含**：所有 UI、状态和事件都在应用内
2. **使用共享组件保持一致性**：主题、通用模式
3. **最小化外壳程序耦合**：只有 4 个必要的耦合点
4. **按顺序注册**：被依赖项在依赖项之前
5. **使用 `apply_over` 切换可见性**：比 `set_visible()` 更可靠
6. **在提前返回之前处理悬停**：在提取 actions 之前检查 event.hits()
7. **恢复选择状态**：当侧边栏重新打开时，调用 `restore_selection_state()`

## 故障排除

### 组件未渲染
- 检查 `live_design(cx)` 是否按正确顺序调用
- 验证 live_design 宏中的导入路径
- 确保设置了 `visible: true`

### 悬停不起作用
- 确保悬停处理在 `Event::Actions` 提前返回之前
- 使用 `Hit::FingerHoverIn` / `Hit::FingerHoverOut`，而不是 `MouseHoverIn`

### 事件未触发
- 确保 `handle_event` 调用了 `self.view.handle_event(...)`
- 验证 live_design 和代码中的按钮 ID 是否匹配

### 动画不流畅
- 在动画更新结束时调用 `self.ui.redraw(cx)`
- 检查 `sidebar_animating` 标志是否在每个事件上被检查

## 统计数据

- **总 Crate 数**: 5（1 个可执行文件，4 个库）
- **总代码行数**: 约 6,000 行 Rust
- **应用数**: 2（mofa-fm, mofa-settings）
- **共享组件数**: 7 个可复用组件
- **默认窗口大小**: 1400x900 像素
- **侧边栏宽度**: 180 像素
