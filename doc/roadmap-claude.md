# MoFA Studio - Critical Architectural Review & Roadmap

> Generated by Claude Code - January 2026

## Executive Summary

The mofa-studio project (~7,845 lines across 27 files) has a clean workspace structure but exhibits **significant architectural issues** that will impede future expansion.

**P0 Status: ✅ ALL COMPLETE** (Code duplication, Font consolidation, Timer management, Debug cleanup, API fixes)

**Expansion Feasibility Score: 3/10** (will improve after P1)

| Aspect | Score | Notes |
|--------|-------|-------|
| Add new app | 2/10 | Requires 6+ file edits |
| Add new widget | 6/10 | mofa-widgets is reusable |
| Change theme | 4/10 | Fonts consolidated ✅, colors still scattered |
| Add new tab | 3/10 | Hardcoded for 2 tabs |
| Modify app UI | 4/10 | Shell coupling makes it fragile |

---

## Critical Issues (P0 - All Resolved)

### 1. Severe Code Duplication (~800+ lines) ✅ RESOLVED

| Component | Files | Status |
|-----------|-------|--------|
| Font definitions | Was 4 copies | ✅ Now single source in `theme.rs` |
| ParticipantPanel | Was 2 copies | ✅ Deleted duplicate from shell |
| LogPanel | Was 2 copies | ✅ Deleted duplicate from shell |

**Solution:** Deleted `participant_panel.rs` and `log_panel.rs` from shell, all imports now use `mofa_widgets::`

### 2. Hardcoded 20-App Limit

The sidebar explicitly lists apps 1-20 with **repetitive code**:

```rust
// sidebar.rs: 60+ lines of copy-paste
if self.view.button(ids!(apps_scroll.app1_btn)).clicked(actions) {
    self.handle_selection(cx, SidebarSelection::App(1));
}
if self.view.button(ids!(apps_scroll.app2_btn)).clicked(actions) {
    self.handle_selection(cx, SidebarSelection::App(2));
}
// ... repeated 18 more times
```

Adding app 21 requires editing 3+ files.

### 3. Timer Resource Management ✅ RESOLVED

**Location:** `apps/mofa-fm/src/screen.rs`

**Original Issue:**
Timers (`audio_timer`, `aec_timer`) continue running when FM page is hidden.

**Research Findings (Makepad API Analysis):**
- Makepad's `LiveHook` trait has NO cleanup/destroy methods
- Makepad's `Widget` trait has NO cleanup/destroy methods
- When widgets become invisible, they persist with all state (including timers)
- `Drop` cannot help because widgets aren't dropped when hidden
- Ironfish (Makepad's flagship app) uses Animator system, not interval timers

**Makepad Timer API:**
```rust
cx.start_interval(duration: f64) -> Timer  // Create repeating timer
cx.start_timeout(duration: f64) -> Timer   // Create one-shot timer
cx.stop_timer(timer: Timer)                // Stop a timer
```

**Solution Implemented:**
1. Added `stop_timers()` and `start_timers()` methods to `MoFaFMScreenRef`
2. Exported `MoFaFMScreenWidgetRefExt` from `mofa-fm/lib.rs`
3. Updated shell's `app.rs` to call these methods on visibility changes:
   - Stop timers when FM page becomes hidden (settings, apps, overlays)
   - Start timers when FM page becomes visible
4. **Converted AEC blink to shader animation** - eliminated `aec_timer` entirely

```rust
// In app.rs - when hiding FM page:
self.ui.mo_fa_fmscreen(ids!(...fm_page)).stop_timers(cx);

// In app.rs - when showing FM page:
self.ui.mo_fa_fmscreen(ids!(...fm_page)).start_timers(cx);
```

**AEC Shader Animation** (eliminated timer):
```glsl
// GPU-driven blink - no Rust timer needed!
let blink = step(0.0, sin(self.time * 2.0)) * self.enabled;
```

**Key Insight:** This is the correct pattern for Makepad timer management.
- Use timers for external data polling (mic level)
- Use shader `self.time` for visual animations (AEC blink)

### 3.1 Makepad API Compatibility Fixes ✅ RESOLVED

Fixed runtime `live_design!` errors from API mismatches:

| File | Field | Issue | Fix |
|------|-------|-------|-----|
| `mofa-fm/screen.rs` | `draw_select` | Doesn't exist on TextInput | Changed to `draw_selection` |
| `mofa-fm/screen.rs` | `icon_walk` | Doesn't exist on DropDown | Removed |
| `mofa-settings/providers_panel.rs` | `icon_walk` | Doesn't exist on RoundedView | Removed |
| `mofa-settings/provider_view.rs` | `draw_label` | Doesn't exist on TextInput | Removed |
| `mofa-settings/*.rs` | `FONT_FAMILY` | Doesn't exist in theme | Removed import |

**Makepad Widget Field Reference:**
- `TextInput`: `draw_text`, `draw_selection`, `draw_cursor`, `draw_bg`
- `DropDown`: `draw_bg`, `draw_text` (NO icon support)
- `Button`: `draw_bg`, `draw_icon`, `icon_walk`
- `Icon`: `draw_icon`, `icon_walk`
- `RoundedView`: `draw_bg` (layout widget, NO icon)

### 4. Shell Tightly Coupled to App Internals

The shell directly accesses 7 levels deep into app widget hierarchies:

```rust
// app.rs line 837: Shell knows MoFaFMScreen's internal structure
let start_view = self.ui.view(ids!(
    body.dashboard_base.content_area.main_content.content.fm_page.mofa_hero.action_section.start_view
));
```

If `MoFaFMScreen` changes its internal layout, the **shell breaks**.

---

## High Severity Issues

### 5. Monolithic Event Handler (227 lines)

`App::handle_event()` handles everything in one method:
- Window resize
- Sidebar hover/click
- User menu hover/click
- Start/stop buttons
- Tab switching
- 20 app button handlers

**Violates Single Responsibility Principle.**

### 6. Adding New Apps Requires 6+ File Edits

To add a new app, you must edit:
1. Create `apps/new-app/` crate
2. `mofa-studio-shell/Cargo.toml` - add dependency + feature
3. `app.rs` - add `live_design(cx)` registration
4. `app.rs` - add `<NewAppScreen>` widget
5. `app.rs` - add visibility toggle logic
6. `sidebar.rs` - add button + click handler
7. `main.rs` - import if using features

**Not a scalable plugin architecture.**

### 7. Tab System Hardcoded for 2 Tabs

```rust
// Comment explicitly says:
#[rust]
open_tabs: Vec<String>,  // Only "profile" and "settings" tabs
```

No extension mechanism for additional tabs.

---

## Medium Severity Issues

### 8. Scattered State Management

Each component manages state independently:
- `MoFaFMScreen`: log_panel_collapsed, audio_devices, splitter_dragging
- `SettingsScreen`: preferences, selected_provider_id
- `App`: user_menu_open, sidebar_menu_open, open_tabs

**No centralized state store.** If components need to communicate, they can't.

### 9. Unused Dead Code

```rust
// lib.rs - never called anywhere
pub fn create_shared_state() -> SharedStateRef {
    Arc::new(Mutex::new(SharedState::default()))
}
```

SharedStateRef exists but is never instantiated or used.

### 10. Magic Strings for Tab IDs

```rust
self.open_or_switch_tab(cx, "profile");   // String literal
self.open_or_switch_tab(cx, "settings");  // String literal

// No enum like:
// enum TabId { Profile, Settings }
```

Type-unsafe, error-prone.

---

## What's Done Well

1. **Clean workspace organization** - shell, widgets, apps separated
2. **Feature flags for optional apps** - mofa-fm, mofa-settings are optional
3. **Proper Makepad Widget patterns** - correct use of `#[deref]`, `live_design!`
4. **Comprehensive architecture documentation** - ARCHITECTURE.md is thorough
5. **Adaptive sidebar height** - dynamic scroll when "Show More" expanded

---

## Summary Table: All Issues

| # | Category | Issue | Severity | Location |
|---|----------|-------|----------|----------|
| 1 | Code Quality | Font duplication | CRITICAL | ~30 lines x 4 files |
| 2 | Code Quality | ParticipantPanel duplication | CRITICAL | ~150 lines x 2 files |
| 2 | Code Quality | LogPanel duplication | CRITICAL | ~68 lines x 2 files |
| 3 | Memory | **Timer memory leak** | CRITICAL | mofa-fm/src/screen.rs |
| 4 | Scalability | Hardcoded 20-app limit | HIGH | sidebar.rs, app.rs |
| 5 | Scalability | Apps require shell edits | HIGH | 6 files to modify |
| 6 | Coupling | Shell accesses app internals | HIGH | app.rs lines 837-856 |
| 7 | Event Handling | 227-line monolithic handle_event | HIGH | app.rs lines 638-865 |
| 8 | State Management | Scattered, uncoordinated state | MEDIUM | All widget files |
| 9 | Code Quality | Hardcoded view paths | MEDIUM | 49 uses of ids!() |
| 10 | Code Quality | Manual hover detection | MEDIUM | app.rs lines 693-744 |
| 11 | Code Quality | Unused dead code | LOW | lib.rs create_shared_state |
| 12 | Code Quality | Debug println! statements | LOW | Multiple files |
| 13 | Code Quality | Naming inconsistency | LOW | snake_case vs camelCase |

---

## Cross-References

This roadmap is part of a three-document analysis:

| Document | Focus | Best For |
|----------|-------|----------|
| **roadmap-claude.md** (this) | Architectural evidence | Understanding WHY problems exist |
| **roadmap-m2.md** | Tactical bug fixes | Quick wins and immediate fixes |
| **roadmap-glm.md** | Strategic planning | Long-term roadmap with grades |

### Key Items from Other Roadmaps

**From roadmap-m2.md:**
- Timer memory leak fix (added to this document)
- Debug println! removal (~15 statements)
- Naming convention standardization
- Conditional debug logging macro

**From roadmap-glm.md:**
- Overall grade: C+ (68/100)
- Testing infrastructure plans (0% → 70% coverage)
- Widget library expansion (buttons, inputs, layouts)
- Risk assessment for each refactoring phase
- Tooling recommendations (ripgrep, cargo-audit, mdbook)

---

## Refactoring Roadmap

### Phase 1: Remove Duplication (Immediate)

**Priority: CRITICAL**

- [ ] Delete duplicate `ParticipantPanel` from `mofa-studio-shell/src/widgets/`
- [ ] Delete duplicate `LogPanel` from `mofa-studio-shell/src/widgets/`
- [ ] Centralize all font definitions in `mofa-widgets/src/theme.rs` only
- [ ] Create `mofa-widgets/src/colors.rs` with all color constants
- [ ] Remove inline hex colors, use constants everywhere

**Expected Impact:** -400 lines of duplicate code

### Phase 2: Fix Tight Coupling (Short-term)

**Priority: HIGH**

- [ ] Apps should emit actions/events, shell should listen (not reach into internals)
- [ ] Create `AppAction` enum for app-to-shell communication
- [ ] Remove direct widget path access from shell into app internals
- [ ] Generate app button handlers with macro instead of copy-paste:

```rust
// Instead of 20 hardcoded handlers, use:
macro_rules! app_button_handler {
    ($($idx:expr),*) => {
        $(
            if self.view.button(ids!(apps_scroll.[<app $idx _btn>])).clicked(actions) {
                self.handle_selection(cx, SidebarSelection::App($idx));
            }
        )*
    };
}
app_button_handler!(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20);
```

**Expected Impact:** -200 lines, improved maintainability

### Phase 3: Dynamic App Registration (Medium-term)

**Priority: HIGH**

- [ ] Create `AppDescriptor` trait for app metadata:

```rust
pub trait AppDescriptor {
    fn id(&self) -> &'static str;
    fn name(&self) -> &'static str;
    fn icon(&self) -> &'static str;
    fn create_screen(&self, cx: &mut Cx) -> WidgetRef;
}
```

- [ ] Create `AppRegistry` to manage app lifecycle
- [ ] Move app registration from hardcoded imports to registry-based
- [ ] Generate sidebar buttons dynamically from registry

**Expected Impact:** Adding new app requires only creating the app crate

### Phase 4: State Management (Medium-term)

**Priority: MEDIUM**

- [ ] Create centralized `AppState` struct
- [ ] Implement state subscription mechanism
- [ ] Remove scattered state from individual widgets
- [ ] Use SharedStateRef properly (currently unused)

```rust
pub struct AppState {
    // Navigation
    pub current_app: AppId,
    pub sidebar_open: bool,

    // User
    pub user_menu_open: bool,
    pub open_tabs: Vec<TabId>,
    pub active_tab: Option<TabId>,

    // App-specific (use trait objects or enums)
    pub app_states: HashMap<AppId, Box<dyn Any>>,
}
```

### Phase 5: Event System Refactor (Long-term)

**Priority: MEDIUM**

- [ ] Split `App::handle_event()` into focused methods:
  - `handle_window_events()`
  - `handle_sidebar_events()`
  - `handle_user_menu_events()`
  - `handle_tab_events()`
  - `handle_app_events()`

- [ ] Create event bus for inter-component communication
- [ ] Replace magic string tab IDs with `TabId` enum

```rust
pub enum TabId {
    Profile,
    Settings,
    // Future tabs can be added here
}
```

### Phase 6: Plugin Architecture (Long-term)

**Priority: LOW (Future)**

- [ ] Implement app manifest system (`app.toml` per app)
- [ ] Support dynamic app loading at runtime
- [ ] Create app sandboxing for isolation
- [ ] Implement theme system with runtime switching

---

## File-by-File Refactoring Notes

### `mofa-studio-shell/src/app.rs`

**Current:** 1,120 lines, monolithic
**Target:** ~600 lines after refactoring

Changes needed:
1. Extract event handlers into separate methods
2. Remove hardcoded app widget paths
3. Use AppRegistry instead of hardcoded imports
4. Remove font/color definitions (use theme.rs)

### `mofa-studio-shell/src/widgets/sidebar.rs`

**Current:** 580 lines with repetitive handlers
**Target:** ~300 lines with macros/loops

Changes needed:
1. Generate app buttons dynamically
2. Use macro for click handlers
3. Remove manual selection state for each button

### `mofa-widgets/src/theme.rs`

**Current:** Only fonts defined
**Target:** Single source of truth for all styling

Add:
1. All color constants
2. Spacing constants
3. Border radius constants
4. Font size presets

### Files to Delete

- `mofa-studio-shell/src/widgets/participant_panel.rs` (use mofa-widgets version)
- `mofa-studio-shell/src/widgets/log_panel.rs` (use mofa-widgets version)

---

## Migration Strategy

### Step 1: Non-Breaking Cleanup
- Remove duplicate files
- Centralize theme constants
- No API changes

### Step 2: Internal Refactoring
- Split event handlers
- Add macros for repetitive code
- Maintain same external behavior

### Step 3: Architecture Changes
- Introduce AppRegistry
- Migrate apps one by one
- Deprecate old patterns

### Step 4: Breaking Changes
- Remove legacy code paths
- Enforce new patterns
- Update documentation

---

## Success Metrics

After completing this roadmap:

| Aspect | Current | Target |
|--------|---------|--------|
| Add new app | 6+ file edits | 1 crate + registry call |
| Change theme | 50+ locations | 1 file |
| Lines of code | ~7,845 | ~5,500 (-30%) |
| Code duplication | ~800 lines | ~0 lines |
| Expansion score | 3/10 | 8/10 |
